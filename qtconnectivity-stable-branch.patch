Andreas Buhr (7):
      Add server role to BlueZ service registration
      Fix error handling in BlueZ connectToServiceHelper
      Correct error handling in QLowEnergyControllerPrivateBluezDBUS
      Change tst_qlowenergycontroller to wait for disconnects
      Fix bug: Let QBluetoothsocket::close emit disconnected only once
      Always call setOpenMode before setSocketState
      Improve detection of enabled location service on SDK<28

Jani Heikkinen (2):
      Bump version
      Bump version

Juha Vuolle (5):
      Fix Linux bluetooth service discovery crash with multiple services
      Use the service's socket protocol info on Bluez bluetooth socket
      Keep the bluetooth service name if the remote has provided it
      Handle LE enhanced connection complete in Bluez peripheral
      Add QIODevice::canReadLine call to QBluetoothSocket

Konstantin Ritt (2):
      Prefer QChar over QString that consists of a single QChar
      Fix "loop variable creates a copy" warning

Oliver Wolff (1):
      QWinRTBluetoothDeviceDiscoveryWorker: Add error handling

Paul Wicking (1):
      Doc: Fix typo

Tarja Sundqvist (7):
      Update commercial license headers
      Revert "Update commercial license headers"
      Bump version
      Bump version
      Merge remote-tracking branch 'origin/tqtc/lts-5.15.4' into tqtc/lts-5.15-opensource
      Merge remote-tracking branch 'origin/tqtc/lts-5.15.5' into tqtc/lts-5.15-opensource
      Merge remote-tracking branch 'origin/tqtc/lts-5.15.6' into tqtc/lts-5.15-opensource

Timur Pocheptsov (2):
      Backport a fix from Qt 6 (stop using a deprecated API)
      CoreBluetooth: add a workaround to enable using scan options

diff --git a/dist/changes-5.15.2 b/dist/changes-5.15.2
deleted file mode 100644
index 904e0eab..00000000
--- a/dist/changes-5.15.2
+++ /dev/null
@@ -1,24 +0,0 @@
-Qt 5.15.2 is a bug-fix release. It maintains both forward and backward
-compatibility (source and binary) with Qt 5.15.1.
-
-For more details, refer to the online documentation included in this
-distribution. The documentation is also available online:
-
-  https://doc.qt.io/qt-5.15/index.html
-
-The Qt version 5.15 series is binary compatible with the 5.14.x series.
-Applications compiled for 5.14 will continue to run with 5.15.
-
-Some of the changes listed in this file include issue tracking numbers
-corresponding to tasks in the Qt Bug Tracker:
-
-  https://bugreports.qt.io/
-
-Each of these identifiers can be entered in the bug tracker to obtain more
-information about a particular change.
-
-****************************************************************************
-*                              Qt 5.15.2                                   *
-****************************************************************************
-
-This release only contains minor changes.
diff --git a/src/bluetooth/bluez/hcimanager.cpp b/src/bluetooth/bluez/hcimanager.cpp
index e2635fae..a8b8e3b9 100644
--- a/src/bluetooth/bluez/hcimanager.cpp
+++ b/src/bluetooth/bluez/hcimanager.cpp
@@ -563,9 +563,11 @@ void HciManager::handleHciAclPacket(const quint8 *data, int size)
 
 void HciManager::handleLeMetaEvent(const quint8 *data)
 {
-    // Spec v4.2, Vol 2, part E, 7.7.65ff
+    // Spec v5.3, Vol 4, part E, 7.7.65.*
     switch (*data) {
-    case 0x1: {
+    case 0x1: // HCI_LE_Connection_Complete
+    case 0xA: // HCI_LE_Enhanced_Connection_Complete
+    {
         const quint16 handle = bt_get_le16(data + 2);
         emit connectionComplete(handle);
         break;
diff --git a/src/bluetooth/doc/src/bluetooth-le-overview.qdoc b/src/bluetooth/doc/src/bluetooth-le-overview.qdoc
index 60181240..7bfc0c44 100644
--- a/src/bluetooth/doc/src/bluetooth-le-overview.qdoc
+++ b/src/bluetooth/doc/src/bluetooth-le-overview.qdoc
@@ -120,7 +120,7 @@ Low Energy devices.
     \row
         \li 0x0004
         \li 0x2803
-        \li UUID 0x2A08, Value handle: 0x0006
+        \li UUID 0x2A08, Value handle: 0x0005
         \li Characteristic of type Date Time
     \row
         \li 0x0005
diff --git a/src/bluetooth/osx/osxbtledeviceinquiry.mm b/src/bluetooth/osx/osxbtledeviceinquiry.mm
index 70b96ab7..e64ac1db 100644
--- a/src/bluetooth/osx/osxbtledeviceinquiry.mm
+++ b/src/bluetooth/osx/osxbtledeviceinquiry.mm
@@ -218,7 +218,15 @@ QT_USE_NAMESPACE
                 [elapsedTimer startWithTimeout:inquiryTimeoutMS step:timeStepMS];
             }
 
-            [manager scanForPeripheralsWithServices:nil options:nil];
+            // ### Qt 6.x: remove the use of env. variable, as soon as a proper public API is in place.
+            bool envOk = false;
+            const int env = qEnvironmentVariableIntValue("QT_BLUETOOTH_SCAN_ENABLE_DUPLICATES", &envOk);
+            if (envOk && env) {
+                [manager scanForPeripheralsWithServices:nil
+                 options:@{CBCentralManagerScanOptionAllowDuplicatesKey : @YES}];
+            } else {
+                [manager scanForPeripheralsWithServices:nil options:nil];
+            }
         } // Else we ignore.
 #if QT_IOS_PLATFORM_SDK_EQUAL_OR_ABOVE(__IPHONE_10_0) || QT_OSX_PLATFORM_SDK_EQUAL_OR_ABOVE(__MAC_10_13)
     } else if (state == CBManagerStateUnsupported || state == CBManagerStateUnauthorized) {
diff --git a/src/bluetooth/osx/osxbtutility.mm b/src/bluetooth/osx/osxbtutility.mm
index e17006de..c7fa7c42 100644
--- a/src/bluetooth/osx/osxbtutility.mm
+++ b/src/bluetooth/osx/osxbtutility.mm
@@ -233,11 +233,17 @@ CFStrongReference<CFUUIDRef> cf_uuid(const QBluetoothUuid &qtUuid)
 
 ObjCStrongReference<CBUUID> cb_uuid(const QBluetoothUuid &qtUuid)
 {
-    CFStrongReference<CFUUIDRef> cfUuid(cf_uuid(qtUuid));
-    if (!cfUuid)
-        return ObjCStrongReference<CBUUID>();
+    bool ok = false;
+    const auto asUInt16 = qToBigEndian(qtUuid.toUInt16(&ok));
+    const auto asUInt128 = qtUuid.toUInt128();
 
-    ObjCStrongReference<CBUUID> cbUuid([CBUUID UUIDWithCFUUID:cfUuid], true); //true == retain.
+    const NSUInteger length = ok ? sizeof asUInt16 : sizeof asUInt128;
+    const void *bytes = &asUInt128;
+    if (ok)
+        bytes = &asUInt16;
+
+    NSData *uuidData = [NSData dataWithBytes:bytes length:length];
+    ObjCStrongReference<CBUUID> cbUuid([CBUUID UUIDWithData:uuidData], true); // true == retain.
     return cbUuid;
 }
 
diff --git a/src/bluetooth/qbluetoothdevicediscoveryagent_android.cpp b/src/bluetooth/qbluetoothdevicediscoveryagent_android.cpp
index fd17faee..53acd2d1 100644
--- a/src/bluetooth/qbluetoothdevicediscoveryagent_android.cpp
+++ b/src/bluetooth/qbluetoothdevicediscoveryagent_android.cpp
@@ -198,18 +198,15 @@ void QBluetoothDeviceDiscoveryAgentPrivate::start(QBluetoothDeviceDiscoveryAgent
         if (QtAndroid::androidSdkVersion() >= 28) {
             locationTurnedOn = bool(locService.callMethod<jboolean>("isLocationEnabled"));
         } else {
-            // try GPS and network provider
-            QAndroidJniObject provider = QAndroidJniObject::getStaticObjectField(
-                        "android/location/LocationManager", "GPS_PROVIDER", "Ljava/lang/String;");
-            bool gpsTurnedOn = bool(locService.callMethod<jboolean>("isProviderEnabled",
-                                      "(Ljava/lang/String;)Z", provider.object<jstring>()));
-
-            provider = QAndroidJniObject::getStaticObjectField(
-                       "android/location/LocationManager", "NETWORK_PROVIDER", "Ljava/lang/String;");
-            bool providerTurnedOn = bool(locService.callMethod<jboolean>("isProviderEnabled",
-                                          "(Ljava/lang/String;)Z", provider.object<jstring>()));
-
-            locationTurnedOn = gpsTurnedOn || providerTurnedOn;
+            // check whether there is any enabled provider
+            QAndroidJniObject listOfEnabledProviders =
+                    locService.callObjectMethod("getProviders", "(Z)Ljava/util/List;", true);
+
+            if (listOfEnabledProviders.isValid()) {
+                int size = listOfEnabledProviders.callMethod<jint>("size", "()I");
+                locationTurnedOn = size > 0;
+                qCDebug(QT_BT_ANDROID) << size << "enabled location providers detected.";
+            }
         }
     }
 
diff --git a/src/bluetooth/qbluetoothdevicediscoveryagent_p.h b/src/bluetooth/qbluetoothdevicediscoveryagent_p.h
index c9a35c3d..5e53bf43 100644
--- a/src/bluetooth/qbluetoothdevicediscoveryagent_p.h
+++ b/src/bluetooth/qbluetoothdevicediscoveryagent_p.h
@@ -224,6 +224,7 @@ private slots:
     void registerDevice(const QBluetoothDeviceInfo &info);
     void updateDeviceData(const QBluetoothAddress &address, QBluetoothDeviceInfo::Fields fields,
                           qint16 rssi, ManufacturerData manufacturerData);
+    void onErrorOccured(QBluetoothDeviceDiscoveryAgent::Error e);
     void onScanFinished();
 
 private:
diff --git a/src/bluetooth/qbluetoothdevicediscoveryagent_winrt.cpp b/src/bluetooth/qbluetoothdevicediscoveryagent_winrt.cpp
index 2562395a..90ebbdd1 100644
--- a/src/bluetooth/qbluetoothdevicediscoveryagent_winrt.cpp
+++ b/src/bluetooth/qbluetoothdevicediscoveryagent_winrt.cpp
@@ -77,6 +77,13 @@ QT_BEGIN_NAMESPACE
 
 Q_DECLARE_LOGGING_CATEGORY(QT_BT_WINRT)
 
+#define EMIT_WORKER_ERROR_AND_RETURN_IF_FAILED(msg, error, ret) \
+    if (FAILED(hr)) { \
+        emit errorOccured(error); \
+        qCWarning(QT_BT_WINRT) << msg; \
+        ret; \
+    }
+
 #define WARN_AND_RETURN_IF_FAILED(msg, ret) \
     if (FAILED(hr)) { \
         qCWarning(QT_BT_WINRT) << msg; \
@@ -156,6 +163,7 @@ Q_SIGNALS:
     void deviceFound(const QBluetoothDeviceInfo &info);
     void deviceDataChanged(const QBluetoothAddress &address, QBluetoothDeviceInfo::Fields,
                            qint16 rssi, ManufacturerData manufacturerData);
+    void errorOccured(QBluetoothDeviceDiscoveryAgent::Error error);
     void scanFinished();
 
 public:
@@ -193,9 +201,13 @@ QWinRTBluetoothDeviceDiscoveryWorker::QWinRTBluetoothDeviceDiscoveryWorker(QBlue
     CoInitialize(NULL);
 #endif
     HRESULT hr = GetActivationFactory(HString::MakeReference(RuntimeClass_Windows_Devices_Bluetooth_BluetoothDevice).Get(), &m_deviceStatics);
-    Q_ASSERT_SUCCEEDED(hr);
+    EMIT_WORKER_ERROR_AND_RETURN_IF_FAILED("Could not obtain bluetooth device factory",
+                                           QBluetoothDeviceDiscoveryAgent::Error::UnknownError,
+                                           return)
     hr = GetActivationFactory(HString::MakeReference(RuntimeClass_Windows_Devices_Bluetooth_BluetoothLEDevice).Get(), &m_leDeviceStatics);
-    Q_ASSERT_SUCCEEDED(hr);
+    EMIT_WORKER_ERROR_AND_RETURN_IF_FAILED("Could not obtain bluetooth le device factory",
+                                           QBluetoothDeviceDiscoveryAgent::Error::UnknownError,
+                                           return)
 }
 
 QWinRTBluetoothDeviceDiscoveryWorker::~QWinRTBluetoothDeviceDiscoveryWorker()
@@ -226,10 +238,14 @@ void QWinRTBluetoothDeviceDiscoveryWorker::stopLEWatcher()
 {
     if (m_leWatcher) {
         HRESULT hr = m_leWatcher->Stop();
-        Q_ASSERT_SUCCEEDED(hr);
+        EMIT_WORKER_ERROR_AND_RETURN_IF_FAILED("Could not stop le watcher",
+                                               QBluetoothDeviceDiscoveryAgent::Error::UnknownError,
+                                               return)
         if (m_leDeviceAddedToken.value) {
             hr = m_leWatcher->remove_Received(m_leDeviceAddedToken);
-            Q_ASSERT_SUCCEEDED(hr);
+            EMIT_WORKER_ERROR_AND_RETURN_IF_FAILED("Could remove le watcher token",
+                                                   QBluetoothDeviceDiscoveryAgent::Error::UnknownError,
+                                                   return)
         }
     }
 }
@@ -239,14 +255,18 @@ void QWinRTBluetoothDeviceDiscoveryWorker::startDeviceDiscovery(QBluetoothDevice
     HString deviceSelector;
     ComPtr<IDeviceInformationStatics> deviceInformationStatics;
     HRESULT hr = GetActivationFactory(HString::MakeReference(RuntimeClass_Windows_Devices_Enumeration_DeviceInformation).Get(), &deviceInformationStatics);
-    WARN_AND_RETURN_IF_FAILED("Could not obtain device information statics", return);
+    EMIT_WORKER_ERROR_AND_RETURN_IF_FAILED("Could not obtain device information statics",
+                                           QBluetoothDeviceDiscoveryAgent::Error::UnknownError,
+                                           return);
     if (mode == QBluetoothDeviceDiscoveryAgent::LowEnergyMethod)
         m_leDeviceStatics->GetDeviceSelector(deviceSelector.GetAddressOf());
     else
         m_deviceStatics->GetDeviceSelector(deviceSelector.GetAddressOf());
     ComPtr<IAsyncOperation<DeviceInformationCollection *>> op;
     hr = deviceInformationStatics->FindAllAsyncAqsFilter(deviceSelector.Get(), &op);
-    WARN_AND_RETURN_IF_FAILED("Could not start bluetooth device discovery operation", return);
+    EMIT_WORKER_ERROR_AND_RETURN_IF_FAILED("Could not start bluetooth device discovery operation",
+                                           QBluetoothDeviceDiscoveryAgent::Error::UnknownError,
+                                           return);
     QPointer<QWinRTBluetoothDeviceDiscoveryWorker> thisPointer(this);
     hr = op->put_Completed(
         Callback<IAsyncOperationCompletedHandler<DeviceInformationCollection *>>([thisPointer, mode](IAsyncOperation<DeviceInformationCollection *> *op, AsyncStatus status) {
@@ -254,7 +274,9 @@ void QWinRTBluetoothDeviceDiscoveryWorker::startDeviceDiscovery(QBluetoothDevice
             thisPointer->onDeviceDiscoveryFinished(op, mode);
         return S_OK;
     }).Get());
-    WARN_AND_RETURN_IF_FAILED("Could not add callback to bluetooth device discovery operation", return);
+    EMIT_WORKER_ERROR_AND_RETURN_IF_FAILED("Could not add device discovery callback",
+                                           QBluetoothDeviceDiscoveryAgent::Error::UnknownError,
+                                           return);
 }
 
 void QWinRTBluetoothDeviceDiscoveryWorker::onDeviceDiscoveryFinished(IAsyncOperation<DeviceInformationCollection *> *op, QBluetoothDeviceDiscoveryAgent::DiscoveryMethod mode)
@@ -264,10 +286,14 @@ void QWinRTBluetoothDeviceDiscoveryWorker::onDeviceDiscoveryFinished(IAsyncOpera
     ComPtr<IVectorView<DeviceInformation *>> devices;
     HRESULT hr;
     hr = op->GetResults(&devices);
-    Q_ASSERT_SUCCEEDED(hr);
+    EMIT_WORKER_ERROR_AND_RETURN_IF_FAILED("Could not obtain discovery result",
+                                           QBluetoothDeviceDiscoveryAgent::Error::UnknownError,
+                                           return);
     quint32 deviceCount;
     hr = devices->get_Size(&deviceCount);
-    Q_ASSERT_SUCCEEDED(hr);
+    EMIT_WORKER_ERROR_AND_RETURN_IF_FAILED("Could not obtain discovery result size",
+                                           QBluetoothDeviceDiscoveryAgent::Error::UnknownError,
+                                           return);
 
     // For classic discovery only paired devices will be found. If we only do classic disovery and
     // no device is found, the scan is finished.
@@ -286,7 +312,9 @@ void QWinRTBluetoothDeviceDiscoveryWorker::gatherDeviceInformation(IDeviceInform
     HString deviceId;
     HRESULT hr;
     hr = deviceInfo->get_Id(deviceId.GetAddressOf());
-    Q_ASSERT_SUCCEEDED(hr);
+    EMIT_WORKER_ERROR_AND_RETURN_IF_FAILED("Could not obtain device ID",
+                                           QBluetoothDeviceDiscoveryAgent::Error::UnknownError,
+                                           return);
     if (mode == QBluetoothDeviceDiscoveryAgent::LowEnergyMethod)
         leBluetoothInfoFromDeviceIdAsync(deviceId.Get());
     else
@@ -299,7 +327,9 @@ void QWinRTBluetoothDeviceDiscoveryWorker::gatherMultipleDeviceInformation(quint
         ComPtr<IDeviceInformation> device;
         HRESULT hr;
         hr = devices->GetAt(i, &device);
-        Q_ASSERT_SUCCEEDED(hr);
+        EMIT_WORKER_ERROR_AND_RETURN_IF_FAILED("Could not obtain device",
+                                               QBluetoothDeviceDiscoveryAgent::Error::UnknownError,
+                                               return);
         gatherDeviceInformation(device.Get(), mode);
     }
 }
@@ -307,24 +337,34 @@ void QWinRTBluetoothDeviceDiscoveryWorker::gatherMultipleDeviceInformation(quint
 void QWinRTBluetoothDeviceDiscoveryWorker::setupLEDeviceWatcher()
 {
     HRESULT hr = RoActivateInstance(HString::MakeReference(RuntimeClass_Windows_Devices_Bluetooth_Advertisement_BluetoothLEAdvertisementWatcher).Get(), &m_leWatcher);
-    Q_ASSERT_SUCCEEDED(hr);
+    EMIT_WORKER_ERROR_AND_RETURN_IF_FAILED("Could not create advertisment watcher",
+                                           QBluetoothDeviceDiscoveryAgent::Error::UnknownError,
+                                           return);
 #if QT_CONFIG(winrt_btle_no_pairing)
     if (supportsNewLEApi()) {
         hr = m_leWatcher->put_ScanningMode(BluetoothLEScanningMode_Active);
-        Q_ASSERT_SUCCEEDED(hr);
+        EMIT_WORKER_ERROR_AND_RETURN_IF_FAILED("Could not set scanning mode",
+                                               QBluetoothDeviceDiscoveryAgent::Error::UnknownError,
+                                               return);
     }
 #endif // winrt_btle_no_pairing
     hr = m_leWatcher->add_Received(Callback<ITypedEventHandler<BluetoothLEAdvertisementWatcher *, BluetoothLEAdvertisementReceivedEventArgs *>>([this](IBluetoothLEAdvertisementWatcher *, IBluetoothLEAdvertisementReceivedEventArgs *args) {
         quint64 address;
         HRESULT hr;
         hr = args->get_BluetoothAddress(&address);
-        Q_ASSERT_SUCCEEDED(hr);
+        EMIT_WORKER_ERROR_AND_RETURN_IF_FAILED("Could not obtain bluetooth address",
+                                       QBluetoothDeviceDiscoveryAgent::Error::UnknownError,
+                                       return S_OK);
         qint16 rssi;
         hr = args->get_RawSignalStrengthInDBm(&rssi);
-        Q_ASSERT_SUCCEEDED(hr);
+        EMIT_WORKER_ERROR_AND_RETURN_IF_FAILED("Could not obtain signal strength",
+                                       QBluetoothDeviceDiscoveryAgent::Error::UnknownError,
+                                       return S_OK);
         ComPtr<IBluetoothLEAdvertisement> ad;
         hr = args->get_Advertisement(&ad);
-        Q_ASSERT_SUCCEEDED(hr);
+        EMIT_WORKER_ERROR_AND_RETURN_IF_FAILED("Could get advertisement",
+                                       QBluetoothDeviceDiscoveryAgent::Error::UnknownError,
+                                       return S_OK);
         const ManufacturerData manufacturerData = extractManufacturerData(ad);
         QBluetoothDeviceInfo::Fields changedFields = QBluetoothDeviceInfo::Field::None;
         if (!m_foundLEManufacturerData.contains(address)) {
@@ -338,15 +378,21 @@ void QWinRTBluetoothDeviceDiscoveryWorker::setupLEDeviceWatcher()
         if (supportsNewLEApi()) {
             ComPtr<IVector<GUID>> guids;
             hr = ad->get_ServiceUuids(&guids);
-            Q_ASSERT_SUCCEEDED(hr);
+            EMIT_WORKER_ERROR_AND_RETURN_IF_FAILED("Could not obtain service uuid list",
+                                           QBluetoothDeviceDiscoveryAgent::Error::UnknownError,
+                                           return S_OK);
             quint32 size;
             hr = guids->get_Size(&size);
-            Q_ASSERT_SUCCEEDED(hr);
             QVector<QBluetoothUuid> serviceUuids;
+            EMIT_WORKER_ERROR_AND_RETURN_IF_FAILED("Could not obtain service uuid list size",
+                                           QBluetoothDeviceDiscoveryAgent::Error::UnknownError,
+                                           return S_OK);
             for (quint32 i = 0; i < size; ++i) {
                 GUID guid;
                 hr = guids->GetAt(i, &guid);
-                Q_ASSERT_SUCCEEDED(hr);
+                EMIT_WORKER_ERROR_AND_RETURN_IF_FAILED("Could not obtain uuid",
+                                               QBluetoothDeviceDiscoveryAgent::Error::UnknownError,
+                                               return S_OK);
                 QBluetoothUuid uuid(guid);
                 serviceUuids.append(uuid);
             }
@@ -409,9 +455,13 @@ void QWinRTBluetoothDeviceDiscoveryWorker::setupLEDeviceWatcher()
         leBluetoothInfoFromAddressAsync(address);
         return S_OK;
     }).Get(), &m_leDeviceAddedToken);
-    Q_ASSERT_SUCCEEDED(hr);
+    EMIT_WORKER_ERROR_AND_RETURN_IF_FAILED("Could not add device callback",
+                                   QBluetoothDeviceDiscoveryAgent::Error::UnknownError,
+                                   return);
     hr = m_leWatcher->Start();
-    Q_ASSERT_SUCCEEDED(hr);
+    EMIT_WORKER_ERROR_AND_RETURN_IF_FAILED("Could not start device watcher",
+                                   QBluetoothDeviceDiscoveryAgent::Error::UnknownError,
+                                   return);
 }
 
 void QWinRTBluetoothDeviceDiscoveryWorker::finishDiscovery()
@@ -458,7 +508,12 @@ void QWinRTBluetoothDeviceDiscoveryWorker::classicBluetoothInfoFromDeviceIdAsync
         }
         return S_OK;
     });
-    Q_ASSERT_SUCCEEDED(hr);
+    if (FAILED(hr)) {
+        emit errorOccured(QBluetoothDeviceDiscoveryAgent::UnknownError);
+        --m_pendingPairedDevices;
+        qCWarning(QT_BT_WINRT) << "Could not obtain bluetooth device from id";
+        return;
+    }
 }
 
 // "deviceFound" will be emitted at the end of the deviceFromIdOperation callback
@@ -492,7 +547,12 @@ void QWinRTBluetoothDeviceDiscoveryWorker::leBluetoothInfoFromDeviceIdAsync(HSTR
         }
         return S_OK;
     });
-    Q_ASSERT_SUCCEEDED(hr);
+    if (FAILED(hr)) {
+        emit errorOccured(QBluetoothDeviceDiscoveryAgent::UnknownError);
+        --m_pendingPairedDevices;
+        qCWarning(QT_BT_WINRT) << "Could not obtain bluetooth device from id";
+        return;
+    }
 }
 
 // "deviceFound" will be emitted at the end of the deviceFromAdressOperation callback
@@ -522,7 +582,11 @@ void QWinRTBluetoothDeviceDiscoveryWorker::leBluetoothInfoFromAddressAsync(quint
         }
         return S_OK;
     });
-    Q_ASSERT_SUCCEEDED(hr);
+    if (FAILED(hr)) {
+        emit errorOccured(QBluetoothDeviceDiscoveryAgent::UnknownError);
+        qCWarning(QT_BT_WINRT) << "Could not obtain bluetooth device from id";
+        return;
+    }
 }
 
 HRESULT QWinRTBluetoothDeviceDiscoveryWorker::onPairedClassicBluetoothDeviceFoundAsync(IAsyncOperation<BluetoothDevice *> *op, AsyncStatus status)
@@ -533,7 +597,9 @@ HRESULT QWinRTBluetoothDeviceDiscoveryWorker::onPairedClassicBluetoothDeviceFoun
 
     ComPtr<IBluetoothDevice> device;
     HRESULT hr = op->GetResults(&device);
-    Q_ASSERT_SUCCEEDED(hr);
+    EMIT_WORKER_ERROR_AND_RETURN_IF_FAILED("Could not obtain bluetooth device",
+                                   QBluetoothDeviceDiscoveryAgent::Error::UnknownError,
+                                   return S_OK);
 
     if (!device)
         return S_OK;
@@ -543,35 +609,53 @@ HRESULT QWinRTBluetoothDeviceDiscoveryWorker::onPairedClassicBluetoothDeviceFoun
     ComPtr<IBluetoothClassOfDevice> classOfDevice;
     UINT32 classOfDeviceInt;
     hr = device->get_BluetoothAddress(&address);
-    Q_ASSERT_SUCCEEDED(hr);
+    EMIT_WORKER_ERROR_AND_RETURN_IF_FAILED("Could not obtain bluetooth address",
+                                   QBluetoothDeviceDiscoveryAgent::Error::UnknownError,
+                                   return S_OK);
     hr = device->get_Name(name.GetAddressOf());
-    Q_ASSERT_SUCCEEDED(hr);
+    EMIT_WORKER_ERROR_AND_RETURN_IF_FAILED("Could not obtain device name",
+                                   QBluetoothDeviceDiscoveryAgent::Error::UnknownError,
+                                   return S_OK);
     const QString btName = QString::fromWCharArray(WindowsGetStringRawBuffer(name.Get(), nullptr));
     hr = device->get_ClassOfDevice(&classOfDevice);
-    Q_ASSERT_SUCCEEDED(hr);
+    EMIT_WORKER_ERROR_AND_RETURN_IF_FAILED("Could not obtain device class",
+                                   QBluetoothDeviceDiscoveryAgent::Error::UnknownError,
+                                   return S_OK);
     hr = classOfDevice->get_RawValue(&classOfDeviceInt);
-    Q_ASSERT_SUCCEEDED(hr);
+    EMIT_WORKER_ERROR_AND_RETURN_IF_FAILED("Could not obtain raw value of device class",
+                                   QBluetoothDeviceDiscoveryAgent::Error::UnknownError,
+                                   return S_OK);
     IVectorView <Rfcomm::RfcommDeviceService *> *deviceServices;
     hr = device->get_RfcommServices(&deviceServices);
     if (hr == E_ACCESSDENIED) {
         qCWarning(QT_BT_WINRT) << "Could not obtain device services. Please check you have "
                                   "permission to access the device.";
     } else {
-        Q_ASSERT_SUCCEEDED(hr);
+        EMIT_WORKER_ERROR_AND_RETURN_IF_FAILED("Could not obtain device services",
+                                       QBluetoothDeviceDiscoveryAgent::Error::UnknownError,
+                                       return S_OK);
         uint serviceCount;
         hr = deviceServices->get_Size(&serviceCount);
-        Q_ASSERT_SUCCEEDED(hr);
+        EMIT_WORKER_ERROR_AND_RETURN_IF_FAILED("Could not obtain service list size",
+                                       QBluetoothDeviceDiscoveryAgent::Error::UnknownError,
+                                       return S_OK);
         QVector<QBluetoothUuid> uuids;
         for (uint i = 0; i < serviceCount; ++i) {
             ComPtr<Rfcomm::IRfcommDeviceService> service;
             hr = deviceServices->GetAt(i, &service);
-            Q_ASSERT_SUCCEEDED(hr);
+            EMIT_WORKER_ERROR_AND_RETURN_IF_FAILED("Could not obtain device service",
+                                           QBluetoothDeviceDiscoveryAgent::Error::UnknownError,
+                                           return S_OK);
             ComPtr<Rfcomm::IRfcommServiceId> id;
             hr = service->get_ServiceId(&id);
-            Q_ASSERT_SUCCEEDED(hr);
+            EMIT_WORKER_ERROR_AND_RETURN_IF_FAILED("Could not obtain service id",
+                                           QBluetoothDeviceDiscoveryAgent::Error::UnknownError,
+                                           return S_OK);
             GUID uuid;
             hr = id->get_Uuid(&uuid);
-            Q_ASSERT_SUCCEEDED(hr);
+            EMIT_WORKER_ERROR_AND_RETURN_IF_FAILED("Could not obtain uuid",
+                                           QBluetoothDeviceDiscoveryAgent::Error::UnknownError,
+                                           return S_OK);
             uuids.append(QBluetoothUuid(uuid));
         }
 
@@ -600,7 +684,9 @@ HRESULT QWinRTBluetoothDeviceDiscoveryWorker::onPairedBluetoothLEDeviceFoundAsyn
     ComPtr<IBluetoothLEDevice> device;
     HRESULT hr;
     hr = op->GetResults(&device);
-    Q_ASSERT_SUCCEEDED(hr);
+    EMIT_WORKER_ERROR_AND_RETURN_IF_FAILED("Could not obtain bluetooth le device",
+                                   QBluetoothDeviceDiscoveryAgent::Error::UnknownError,
+                                   return S_OK);
 #if QT_CONFIG(winrt_btle_no_pairing)
     if (supportsNewLEApi())
         return onBluetoothLEDeviceFound(device);
@@ -617,7 +703,9 @@ HRESULT QWinRTBluetoothDeviceDiscoveryWorker::onBluetoothLEDeviceFoundAsync(IAsy
     ComPtr<IBluetoothLEDevice> device;
     HRESULT hr;
     hr = op->GetResults(&device);
-    Q_ASSERT_SUCCEEDED(hr);
+    EMIT_WORKER_ERROR_AND_RETURN_IF_FAILED("Could not obtain bluetooth le device",
+                                   QBluetoothDeviceDiscoveryAgent::Error::UnknownError,
+                                   return S_OK);
 #if QT_CONFIG(winrt_btle_no_pairing)
     if (supportsNewLEApi())
         return onBluetoothLEDeviceFound(device);
@@ -636,31 +724,45 @@ HRESULT QWinRTBluetoothDeviceDiscoveryWorker::onBluetoothLEDeviceFound(ComPtr<IB
     if (pairingCheck == CheckForPairing) {
         ComPtr<IBluetoothLEDevice2> device2;
         HRESULT hr = device.As(&device2);
-        Q_ASSERT_SUCCEEDED(hr);
+        EMIT_WORKER_ERROR_AND_RETURN_IF_FAILED("Could not cast device to Device2",
+                                       QBluetoothDeviceDiscoveryAgent::Error::UnknownError,
+                                       return S_OK);
         ComPtr<IDeviceInformation> deviceInfo;
         hr = device2->get_DeviceInformation(&deviceInfo);
-        Q_ASSERT_SUCCEEDED(hr);
+        EMIT_WORKER_ERROR_AND_RETURN_IF_FAILED("Could not obtain device info",
+                                       QBluetoothDeviceDiscoveryAgent::Error::UnknownError,
+                                       return S_OK);
         if (!deviceInfo) {
             qCDebug(QT_BT_WINRT) << "onBluetoothLEDeviceFound: Could not obtain device information";
             return S_OK;
         }
         ComPtr<IDeviceInformation2> deviceInfo2;
         hr = deviceInfo.As(&deviceInfo2);
-        Q_ASSERT_SUCCEEDED(hr);
+        EMIT_WORKER_ERROR_AND_RETURN_IF_FAILED("Could not cast device to DeviceInfo2",
+                                       QBluetoothDeviceDiscoveryAgent::Error::UnknownError,
+                                       return S_OK);
         ComPtr<IDeviceInformationPairing> pairing;
         hr = deviceInfo2->get_Pairing(&pairing);
-        Q_ASSERT_SUCCEEDED(hr);
+        EMIT_WORKER_ERROR_AND_RETURN_IF_FAILED("Could not obtain pairing information",
+                                       QBluetoothDeviceDiscoveryAgent::Error::UnknownError,
+                                       return S_OK);
         boolean isPaired;
         hr = pairing->get_IsPaired(&isPaired);
-        Q_ASSERT_SUCCEEDED(hr);
+        EMIT_WORKER_ERROR_AND_RETURN_IF_FAILED("Could not obtain pairing status",
+                                       QBluetoothDeviceDiscoveryAgent::Error::UnknownError,
+                                       return S_OK);
         // We need a paired device in order to be able to obtain its information
         if (!isPaired) {
             ComPtr<IAsyncOperation<DevicePairingResult *>> pairingOp;
             QPointer<QWinRTBluetoothDeviceDiscoveryWorker> tPointer(this);
             hr = pairing.Get()->PairAsync(&pairingOp);
-            Q_ASSERT_SUCCEEDED(hr);
-            pairingOp->put_Completed(
-                Callback<IAsyncOperationCompletedHandler<DevicePairingResult *>>([device, tPointer](IAsyncOperation<DevicePairingResult *> *op, AsyncStatus status) {
+            EMIT_WORKER_ERROR_AND_RETURN_IF_FAILED("Could not initiate pairing",
+                                           QBluetoothDeviceDiscoveryAgent::Error::UnknownError,
+                                           return S_OK);
+            hr = pairingOp->put_Completed(
+                Callback<IAsyncOperationCompletedHandler<DevicePairingResult *>>
+                        ([device, tPointer]
+                         (IAsyncOperation<DevicePairingResult *> *op, AsyncStatus status) {
                 if (!tPointer)
                     return S_OK;
 
@@ -670,19 +772,28 @@ HRESULT QWinRTBluetoothDeviceDiscoveryWorker::onBluetoothLEDeviceFound(ComPtr<IB
                 }
 
                 ComPtr<IDevicePairingResult> result;
-                op->GetResults(&result);
+                HRESULT hr;
+                hr = op->GetResults(&result);
+                if (FAILED(hr)) {
+                    emit tPointer->errorOccured(QBluetoothDeviceDiscoveryAgent::UnknownError);
+                    qCWarning(QT_BT_WINRT) << "Could not obtain pairing result";
+                    return S_OK;
+                }
 
                 DevicePairingResultStatus pairingStatus;
-                result.Get()->get_Status(&pairingStatus);
-
-                if (pairingStatus != DevicePairingResultStatus_Paired) {
-                    qCDebug(QT_BT_WINRT) << "Could not pair device";
+                hr = result.Get()->get_Status(&pairingStatus);
+                if (FAILED(hr) || pairingStatus != DevicePairingResultStatus_Paired) {
+                    emit tPointer->errorOccured(QBluetoothDeviceDiscoveryAgent::UnknownError);
+                    qCWarning(QT_BT_WINRT) << "Device pairing failed";
                     return S_OK;
                 }
 
                 tPointer->onBluetoothLEDeviceFound(device, OmitPairingCheck);
                 return S_OK;
             }).Get());
+            EMIT_WORKER_ERROR_AND_RETURN_IF_FAILED("Could not obtain register pairing callback",
+                                           QBluetoothDeviceDiscoveryAgent::Error::UnknownError,
+                                           return S_OK);
             return S_OK;
         }
     }
@@ -690,25 +801,37 @@ HRESULT QWinRTBluetoothDeviceDiscoveryWorker::onBluetoothLEDeviceFound(ComPtr<IB
     UINT64 address;
     HString name;
     HRESULT hr = device->get_BluetoothAddress(&address);
-    Q_ASSERT_SUCCEEDED(hr);
+    EMIT_WORKER_ERROR_AND_RETURN_IF_FAILED("Could not obtain bluetooth address",
+                                   QBluetoothDeviceDiscoveryAgent::Error::UnknownError,
+                                   return S_OK);
     hr = device->get_Name(name.GetAddressOf());
-    Q_ASSERT_SUCCEEDED(hr);
+    EMIT_WORKER_ERROR_AND_RETURN_IF_FAILED("Could not obtain device name",
+                                   QBluetoothDeviceDiscoveryAgent::Error::UnknownError,
+                                   return S_OK);
     const QString btName = QString::fromWCharArray(WindowsGetStringRawBuffer(name.Get(), nullptr));
     IVectorView <GenericAttributeProfile::GattDeviceService *> *deviceServices;
     hr = device->get_GattServices(&deviceServices);
-    Q_ASSERT_SUCCEEDED(hr);
+    EMIT_WORKER_ERROR_AND_RETURN_IF_FAILED("Could not obtain gatt service list",
+                                   QBluetoothDeviceDiscoveryAgent::Error::UnknownError,
+                                   return S_OK);
     uint serviceCount;
     hr = deviceServices->get_Size(&serviceCount);
-    Q_ASSERT_SUCCEEDED(hr);
+    EMIT_WORKER_ERROR_AND_RETURN_IF_FAILED("Could not obtain gatt service list size",
+                                           QBluetoothDeviceDiscoveryAgent::Error::UnknownError,
+                                           return S_OK);
     QVector<QBluetoothUuid> uuids;
     for (uint i = 0; i < serviceCount; ++i) {
         ComPtr<GenericAttributeProfile::IGattDeviceService> service;
         hr = deviceServices->GetAt(i, &service);
-        Q_ASSERT_SUCCEEDED(hr);
+        EMIT_WORKER_ERROR_AND_RETURN_IF_FAILED("Could not obtain gatt service",
+                                       QBluetoothDeviceDiscoveryAgent::Error::UnknownError,
+                                       return S_OK);
         ComPtr<Rfcomm::IRfcommServiceId> id;
         GUID uuid;
         hr = service->get_Uuid(&uuid);
-        Q_ASSERT_SUCCEEDED(hr);
+        EMIT_WORKER_ERROR_AND_RETURN_IF_FAILED("Could not obtain gatt service uuid",
+                                       QBluetoothDeviceDiscoveryAgent::Error::UnknownError,
+                                       return S_OK);
         uuids.append(QBluetoothUuid(uuid));
     }
     const qint16 rssi = m_foundLEDevices.value(address);
@@ -742,30 +865,44 @@ HRESULT QWinRTBluetoothDeviceDiscoveryWorker::onBluetoothLEDeviceFound(ComPtr<IB
     UINT64 address;
     HString name;
     HRESULT hr = device->get_BluetoothAddress(&address);
-    Q_ASSERT_SUCCEEDED(hr);
+    EMIT_WORKER_ERROR_AND_RETURN_IF_FAILED("Could not obtain bluetooth address",
+                                           QBluetoothDeviceDiscoveryAgent::Error::UnknownError,
+                                           return S_OK);
     hr = device->get_Name(name.GetAddressOf());
-    Q_ASSERT_SUCCEEDED(hr);
+    EMIT_WORKER_ERROR_AND_RETURN_IF_FAILED("Could not obtain device name",
+                                           QBluetoothDeviceDiscoveryAgent::Error::UnknownError,
+                                           return S_OK);
     const QString btName = QString::fromWCharArray(WindowsGetStringRawBuffer(name.Get(), nullptr));
 
     ComPtr<IBluetoothLEDevice2> device2;
     hr = device.As(&device2);
-    Q_ASSERT_SUCCEEDED(hr);
+    EMIT_WORKER_ERROR_AND_RETURN_IF_FAILED("Could not cast device",
+                                           QBluetoothDeviceDiscoveryAgent::Error::UnknownError,
+                                           return S_OK);
     ComPtr<IDeviceInformation> deviceInfo;
     hr = device2->get_DeviceInformation(&deviceInfo);
-    Q_ASSERT_SUCCEEDED(hr);
+    EMIT_WORKER_ERROR_AND_RETURN_IF_FAILED("Could not obtain device info",
+                                           QBluetoothDeviceDiscoveryAgent::Error::UnknownError,
+                                           return S_OK);
     if (!deviceInfo) {
         qCDebug(QT_BT_WINRT) << "onBluetoothLEDeviceFound: Could not obtain device information";
         return S_OK;
     }
     ComPtr<IDeviceInformation2> deviceInfo2;
     hr = deviceInfo.As(&deviceInfo2);
-    Q_ASSERT_SUCCEEDED(hr);
+    EMIT_WORKER_ERROR_AND_RETURN_IF_FAILED("Could not obtain cast device info",
+                                           QBluetoothDeviceDiscoveryAgent::Error::UnknownError,
+                                           return S_OK);
     ComPtr<IDeviceInformationPairing> pairing;
     hr = deviceInfo2->get_Pairing(&pairing);
-    Q_ASSERT_SUCCEEDED(hr);
+    EMIT_WORKER_ERROR_AND_RETURN_IF_FAILED("Could not obtain pairing information",
+                                           QBluetoothDeviceDiscoveryAgent::Error::UnknownError,
+                                           return S_OK);
     boolean isPaired;
     hr = pairing->get_IsPaired(&isPaired);
-    Q_ASSERT_SUCCEEDED(hr);
+    EMIT_WORKER_ERROR_AND_RETURN_IF_FAILED("Could not obtain pairing status",
+                                           QBluetoothDeviceDiscoveryAgent::Error::UnknownError,
+                                           return S_OK);
     QVector<QBluetoothUuid> uuids;
 
     const LEAdvertisingInfo adInfo = m_foundLEDevicesMap.value(address);
@@ -776,17 +913,25 @@ HRESULT QWinRTBluetoothDeviceDiscoveryWorker::onBluetoothLEDeviceFound(ComPtr<IB
     } else {
         IVectorView <GenericAttributeProfile::GattDeviceService *> *deviceServices;
         hr = device->get_GattServices(&deviceServices);
-        Q_ASSERT_SUCCEEDED(hr);
+        EMIT_WORKER_ERROR_AND_RETURN_IF_FAILED("Could not obtain gatt service list",
+                                               QBluetoothDeviceDiscoveryAgent::Error::UnknownError,
+                                               return S_OK);
         uint serviceCount;
         hr = deviceServices->get_Size(&serviceCount);
-        Q_ASSERT_SUCCEEDED(hr);
+        EMIT_WORKER_ERROR_AND_RETURN_IF_FAILED("Could not obtain gatt service list size",
+                                               QBluetoothDeviceDiscoveryAgent::Error::UnknownError,
+                                               return S_OK);
         for (uint i = 0; i < serviceCount; ++i) {
             ComPtr<GenericAttributeProfile::IGattDeviceService> service;
             hr = deviceServices->GetAt(i, &service);
-            Q_ASSERT_SUCCEEDED(hr);
+            EMIT_WORKER_ERROR_AND_RETURN_IF_FAILED("Could not obtain gatt service",
+                                                   QBluetoothDeviceDiscoveryAgent::Error::UnknownError,
+                                                   return S_OK);
             GUID uuid;
             hr = service->get_Uuid(&uuid);
-            Q_ASSERT_SUCCEEDED(hr);
+            EMIT_WORKER_ERROR_AND_RETURN_IF_FAILED("Could not obtain uuid",
+                                                   QBluetoothDeviceDiscoveryAgent::Error::UnknownError,
+                                                   return S_OK);
             uuids.append(QBluetoothUuid(uuid));
         }
     }
@@ -849,6 +994,8 @@ void QBluetoothDeviceDiscoveryAgentPrivate::start(QBluetoothDeviceDiscoveryAgent
             this, &QBluetoothDeviceDiscoveryAgentPrivate::registerDevice);
     connect(worker, &QWinRTBluetoothDeviceDiscoveryWorker::deviceDataChanged,
             this, &QBluetoothDeviceDiscoveryAgentPrivate::updateDeviceData);
+    connect(worker, &QWinRTBluetoothDeviceDiscoveryWorker::errorOccured,
+            this, &QBluetoothDeviceDiscoveryAgentPrivate::onErrorOccured);
     connect(worker, &QWinRTBluetoothDeviceDiscoveryWorker::scanFinished,
             this, &QBluetoothDeviceDiscoveryAgentPrivate::onScanFinished);
     worker->start();
@@ -925,6 +1072,13 @@ void QBluetoothDeviceDiscoveryAgentPrivate::updateDeviceData(const QBluetoothAdd
     }
 }
 
+void QBluetoothDeviceDiscoveryAgentPrivate::onErrorOccured(QBluetoothDeviceDiscoveryAgent::Error e)
+{
+    Q_Q(QBluetoothDeviceDiscoveryAgent);
+    lastError = e;
+    emit q->error(e);
+}
+
 void QBluetoothDeviceDiscoveryAgentPrivate::onScanFinished()
 {
     Q_Q(QBluetoothDeviceDiscoveryAgent);
diff --git a/src/bluetooth/qbluetoothservicediscoveryagent_bluez.cpp b/src/bluetooth/qbluetoothservicediscoveryagent_bluez.cpp
index 6a93143b..4a18cfc7 100644
--- a/src/bluetooth/qbluetoothservicediscoveryagent_bluez.cpp
+++ b/src/bluetooth/qbluetoothservicediscoveryagent_bluez.cpp
@@ -320,7 +320,10 @@ void QBluetoothServiceDiscoveryAgentPrivate::_q_finishSdpScan(QBluetoothServiceD
             for (const QBluetoothUuid &id : serviceClassUuids) {
                 if (id.minimumSize() == 16) {
                     serviceInfo.setServiceUuid(id);
-                    serviceInfo.setServiceName(QBluetoothServiceDiscoveryAgent::tr("Custom Service"));
+                    if (serviceInfo.serviceName().isEmpty()) {
+                        serviceInfo.setServiceName(
+                                    QBluetoothServiceDiscoveryAgent::tr("Custom Service"));
+                    }
                     QBluetoothServiceInfo::Sequence modSeq =
                             serviceInfo.attribute(QBluetoothServiceInfo::ServiceClassIds).value<QBluetoothServiceInfo::Sequence>();
                     modSeq.removeOne(QVariant::fromValue(id));
@@ -334,8 +337,10 @@ void QBluetoothServiceDiscoveryAgentPrivate::_q_finishSdpScan(QBluetoothServiceD
                 qCDebug(QT_BT_BLUEZ) << "Discovered services" << discoveredDevices.at(0).address().toString()
                                      << serviceInfo.serviceName() << serviceInfo.serviceUuid()
                                      << ">>>" << serviceInfo.serviceClassUuids();
-
-                emit q->serviceDiscovered(serviceInfo);
+                // Use queued connection to allow us finish the service looping; the application
+                // might call stop() when it has detected the service-of-interest.
+                QMetaObject::invokeMethod(q, "serviceDiscovered", Qt::QueuedConnection,
+                                          Q_ARG(QBluetoothServiceInfo, serviceInfo));
             }
         }
     }
diff --git a/src/bluetooth/qbluetoothserviceinfo_bluez.cpp b/src/bluetooth/qbluetoothserviceinfo_bluez.cpp
index d91367c4..418d0a1f 100644
--- a/src/bluetooth/qbluetoothserviceinfo_bluez.cpp
+++ b/src/bluetooth/qbluetoothserviceinfo_bluez.cpp
@@ -297,6 +297,7 @@ bool QBluetoothServiceInfoPrivate::registerService(const QBluetoothAddress &loca
 
         QVariantMap mapping;
         mapping.insert(QStringLiteral("ServiceRecord"), xmlServiceRecord);
+        mapping.insert(QStringLiteral("Role"), QStringLiteral("server"));
 
         // Strategy to pick service uuid
         // 1.) use serviceUuid()
diff --git a/src/bluetooth/qbluetoothsocket.cpp b/src/bluetooth/qbluetoothsocket.cpp
index e4d85447..aadd4755 100644
--- a/src/bluetooth/qbluetoothsocket.cpp
+++ b/src/bluetooth/qbluetoothsocket.cpp
@@ -593,7 +593,7 @@ void QBluetoothSocket::setSocketState(QBluetoothSocket::SocketState state)
 bool QBluetoothSocket::canReadLine() const
 {
     Q_D(const QBluetoothSocketBase);
-    return d->canReadLine();
+    return d->canReadLine() || QIODevice::canReadLine();
 }
 
 /*!
diff --git a/src/bluetooth/qbluetoothsocket_bluez.cpp b/src/bluetooth/qbluetoothsocket_bluez.cpp
index e7d06f2e..2c22fde6 100644
--- a/src/bluetooth/qbluetoothsocket_bluez.cpp
+++ b/src/bluetooth/qbluetoothsocket_bluez.cpp
@@ -689,8 +689,8 @@ bool QBluetoothSocketPrivateBluez::setSocketDescriptor(int socketDescriptor, QBl
     connectWriteNotifier = new QSocketNotifier(socket, QSocketNotifier::Write, q);
     QObject::connect(connectWriteNotifier, SIGNAL(activated(QSocketDescriptor)), this, SLOT(_q_writeNotify()));
 
-    q->setSocketState(socketState);
     q->setOpenMode(openMode);
+    q->setSocketState(socketState);
 
     return true;
 }
diff --git a/src/bluetooth/qbluetoothsocket_bluezdbus.cpp b/src/bluetooth/qbluetoothsocket_bluezdbus.cpp
index d3fc13e4..d6aa17a7 100644
--- a/src/bluetooth/qbluetoothsocket_bluezdbus.cpp
+++ b/src/bluetooth/qbluetoothsocket_bluezdbus.cpp
@@ -238,18 +238,29 @@ void QBluetoothSocketPrivateBluezDBus::connectToServiceHelper(
     OrgBluezDevice1Interface device(QStringLiteral("org.bluez"), remoteDevicePath,
                                     QDBusConnection::systemBus());
     reply = device.ConnectProfile(profileUuid);
+    QDBusPendingCallWatcher *watcher = new QDBusPendingCallWatcher(reply, this);
+    connect(watcher, &QDBusPendingCallWatcher::finished,
+            this, &QBluetoothSocketPrivateBluezDBus::connectToServiceReplyHandler);
+
+    q->setOpenMode(openMode);
+    q->setSocketState(QBluetoothSocket::ConnectingState);
+}
+
+void QBluetoothSocketPrivateBluezDBus::connectToServiceReplyHandler(
+        QDBusPendingCallWatcher *watcher)
+{
+    Q_Q(QBluetoothSocket);
+
+    QDBusPendingReply<> reply = *watcher;
     if (reply.isError()) {
-        qCWarning(QT_BT_BLUEZ) << "Cannot connect to profile/service:" << uuid;
+        qCWarning(QT_BT_BLUEZ) << "Cannot connect to profile/service.";
 
         clearSocket();
 
         errorString = QBluetoothSocket::tr("Cannot connect to remote profile");
         q->setSocketError(QBluetoothSocket::HostNotFoundError);
-        return;
     }
-
-    q->setOpenMode(openMode);
-    q->setSocketState(QBluetoothSocket::ConnectingState);
+    watcher->deleteLater();
 }
 
 void QBluetoothSocketPrivateBluezDBus::connectToService(
@@ -273,6 +284,10 @@ void QBluetoothSocketPrivateBluezDBus::connectToService(
         return;
     }
 
+    if (service.socketProtocol() != QBluetoothServiceInfo::Protocol::UnknownProtocol)
+        socketType = service.socketProtocol();
+    qCDebug(QT_BT_BLUEZ) << "Socket protocol used:" << socketType;
+
     connectToService(service.device().address(), targetService, openMode);
 }
 
diff --git a/src/bluetooth/qbluetoothsocket_bluezdbus_p.h b/src/bluetooth/qbluetoothsocket_bluezdbus_p.h
index 4d1a272e..7f195cdd 100644
--- a/src/bluetooth/qbluetoothsocket_bluezdbus_p.h
+++ b/src/bluetooth/qbluetoothsocket_bluezdbus_p.h
@@ -56,6 +56,7 @@
 #include <QtDBus/qdbusunixfiledescriptor.h>
 
 #include <QtNetwork/qlocalsocket.h>
+#include <QDBusPendingCallWatcher>
 
 class OrgBluezProfileManager1Interface;
 
@@ -110,6 +111,9 @@ public:
     bool canReadLine() const override;
     qint64 bytesToWrite() const override;
 
+public slots:
+    void connectToServiceReplyHandler(QDBusPendingCallWatcher *);
+
 private:
     void remoteConnected(const QDBusUnixFileDescriptor &fd);
     void socketStateChanged(QLocalSocket::LocalSocketState newState);
diff --git a/src/bluetooth/qbluetoothsocket_osx.mm b/src/bluetooth/qbluetoothsocket_osx.mm
index 8af085ac..dcb9aa03 100644
--- a/src/bluetooth/qbluetoothsocket_osx.mm
+++ b/src/bluetooth/qbluetoothsocket_osx.mm
@@ -519,8 +519,8 @@ void QBluetoothSocketPrivate::channelOpenComplete()
     Q_ASSERT_X(q_ptr, Q_FUNC_INFO, "invalid q_ptr (null)");
 
     if (!isConnecting) {
-        q_ptr->setSocketState(QBluetoothSocket::ConnectedState);
         q_ptr->setOpenMode(openMode);
+        q_ptr->setSocketState(QBluetoothSocket::ConnectedState);
         emit q_ptr->connected();
     } else {
         state = QBluetoothSocket::ConnectedState;
@@ -537,10 +537,9 @@ void QBluetoothSocketPrivate::channelClosed()
     // (thus close/abort probably will not work).
 
     if (!isConnecting) {
-        q_ptr->setSocketState(QBluetoothSocket::UnconnectedState);
         q_ptr->setOpenMode(QIODevice::NotOpen);
+        q_ptr->setSocketState(QBluetoothSocket::UnconnectedState);
         emit q_ptr->readChannelFinished();
-        emit q_ptr->disconnected();
     } else {
         state = QBluetoothSocket::UnconnectedState;
         // We are still in connectToService and do not want
diff --git a/src/bluetooth/qbluetoothsocket_win.cpp b/src/bluetooth/qbluetoothsocket_win.cpp
index 83855323..0fe22f6e 100644
--- a/src/bluetooth/qbluetoothsocket_win.cpp
+++ b/src/bluetooth/qbluetoothsocket_win.cpp
@@ -133,8 +133,8 @@ void QBluetoothSocketPrivateWin::connectToServiceHelper(const QBluetoothAddress
 
     const int error = ::WSAGetLastError();
     if (result != SOCKET_ERROR || error == WSAEWOULDBLOCK) {
-        q->setSocketState(QBluetoothSocket::ConnectingState);
         q->setOpenMode(openMode);
+        q->setSocketState(QBluetoothSocket::ConnectingState);
     } else {
         errorString = qt_error_string(error);
         q->setSocketError(QBluetoothSocket::UnknownSocketError);
@@ -341,10 +341,12 @@ void QBluetoothSocketPrivateWin::abort()
     Q_Q(QBluetoothSocket);
 
     const bool wasConnected = q->state() == QBluetoothSocket::ConnectedState;
-    q->setSocketState(QBluetoothSocket::UnconnectedState);
     if (wasConnected) {
         q->setOpenMode(QIODevice::NotOpen);
+        q->setSocketState(QBluetoothSocket::UnconnectedState);
         emit q->readChannelFinished();
+    } else {
+        q->setSocketState(QBluetoothSocket::UnconnectedState);
     }
 }
 
@@ -509,8 +511,8 @@ bool QBluetoothSocketPrivateWin::setSocketDescriptor(int socketDescriptor,
 
     if (!createNotifiers())
         return false;
-    q->setSocketState(socketState);
     q->setOpenMode(openMode);
+    q->setSocketState(socketState);
     if (socketState == QBluetoothSocket::ConnectedState) {
         connectWriteNotifier->setEnabled(true);
         readNotifier->setEnabled(true);
diff --git a/src/bluetooth/qlowenergycontroller_android.cpp b/src/bluetooth/qlowenergycontroller_android.cpp
index e0a59ddd..e0f3eef7 100644
--- a/src/bluetooth/qlowenergycontroller_android.cpp
+++ b/src/bluetooth/qlowenergycontroller_android.cpp
@@ -502,7 +502,7 @@ void QLowEnergyControllerPrivateAndroid::servicesDiscovered(
 
     if (errorCode == QLowEnergyController::NoError) {
         //Android delivers all services in one go
-        const QStringList list = foundServices.split(QStringLiteral(" "), Qt::SkipEmptyParts);
+        const QStringList list = foundServices.split(QChar::Space, Qt::SkipEmptyParts);
         for (const QString &entry : list) {
             const QBluetoothUuid service(entry);
             if (service.isNull())
@@ -550,8 +550,7 @@ void QLowEnergyControllerPrivateAndroid::serviceDetailsDiscoveryFinished(
                                         uuid.object<jstring>());
         if (javaIncludes.isValid()) {
             const QStringList list = javaIncludes.toString()
-                                                 .split(QStringLiteral(" "),
-                                                        Qt::SkipEmptyParts);
+                                         .split(QChar::Space, Qt::SkipEmptyParts);
             for (const QString &entry : list) {
                 const QBluetoothUuid service(entry);
                 if (service.isNull())
@@ -928,8 +927,8 @@ static QAndroidJniObject createJavaAdvertiseData(const QLowEnergyAdvertisingData
                                        !data.localName().isEmpty());
     builder = builder.callObjectMethod("setIncludeTxPowerLevel", "(Z)Landroid/bluetooth/le/AdvertiseData$Builder;",
                                        data.includePowerLevel());
-    for (const auto service: data.services())
-    {
+    const auto services = data.services();
+    for (const auto &service : services) {
         builder = builder.callObjectMethod("addServiceUuid",
                                        "(Landroid/os/ParcelUuid;)Landroid/bluetooth/le/AdvertiseData$Builder;",
                                        javaParcelUuidfromQtUuid(service).object());
diff --git a/src/bluetooth/qlowenergycontroller_bluezdbus.cpp b/src/bluetooth/qlowenergycontroller_bluezdbus.cpp
index d69fb6cd..c159e97e 100644
--- a/src/bluetooth/qlowenergycontroller_bluezdbus.cpp
+++ b/src/bluetooth/qlowenergycontroller_bluezdbus.cpp
@@ -60,6 +60,9 @@ QLowEnergyControllerPrivateBluezDBus::QLowEnergyControllerPrivateBluezDBus()
 
 QLowEnergyControllerPrivateBluezDBus::~QLowEnergyControllerPrivateBluezDBus()
 {
+    if (state != QLowEnergyController::UnconnectedState) {
+        qCWarning(QT_BT_BLUEZ) << "Low Energy Controller deleted while connected.";
+    }
 }
 
 void QLowEnergyControllerPrivateBluezDBus::init()
@@ -208,12 +211,17 @@ void QLowEnergyControllerPrivateBluezDBus::characteristicPropertiesChanged(
         emit service->characteristicChanged(changedChar, newValue);
 }
 
-void QLowEnergyControllerPrivateBluezDBus::interfacesRemoved(
-        const QDBusObjectPath &objectPath, const QStringList &/*interfaces*/)
+void QLowEnergyControllerPrivateBluezDBus::interfacesRemoved(const QDBusObjectPath &objectPath,
+                                                             const QStringList &interfaces)
 {
     if (objectPath.path() == device->path()) {
-        qCWarning(QT_BT_BLUEZ) << "DBus Device1 was removed";
-        executeClose(QLowEnergyController::UnknownRemoteDeviceError);
+        if (interfaces.contains(QStringLiteral("org.bluez.Device1"))) {
+            qCWarning(QT_BT_BLUEZ) << "DBus Device1 was removed";
+            executeClose(QLowEnergyController::UnknownRemoteDeviceError);
+        } else {
+            qCDebug(QT_BT_BLUEZ) << "DBus interfaces" << interfaces << "were removed from"
+                                 << objectPath.path();
+        }
     } else if (objectPath.path() == adapter->path()) {
         qCWarning(QT_BT_BLUEZ) << "DBus Adapter was removed";
         executeClose(QLowEnergyController::InvalidBluetoothAdapterError);
@@ -385,6 +393,8 @@ void QLowEnergyControllerPrivateBluezDBus::disconnectFromDevice()
             qCDebug(QT_BT_BLUEZ) << "BTLE_DBUS::disconnect() failed"
                                  << reply.reply().errorName()
                                  << reply.reply().errorMessage();
+            executeClose(QLowEnergyController::UnknownError);
+        } else {
             executeClose(QLowEnergyController::NoError);
         }
         call->deleteLater();
diff --git a/src/bluetooth/qlowenergycontrollerbase.cpp b/src/bluetooth/qlowenergycontrollerbase.cpp
index 059bd41b..d151f871 100644
--- a/src/bluetooth/qlowenergycontrollerbase.cpp
+++ b/src/bluetooth/qlowenergycontrollerbase.cpp
@@ -123,6 +123,7 @@ void QLowEnergyControllerPrivate::setError(
 void QLowEnergyControllerPrivate::setState(
         QLowEnergyController::ControllerState newState)
 {
+    qCDebug(QT_BT) << "QLowEnergyControllerPrivate setting state to" << newState;
     Q_Q(QLowEnergyController);
     if (state == newState)
         return;
diff --git a/tests/auto/qbluetoothsocket/tst_qbluetoothsocket.cpp b/tests/auto/qbluetoothsocket/tst_qbluetoothsocket.cpp
index 05bc1a0f..a7b5ef1f 100644
--- a/tests/auto/qbluetoothsocket/tst_qbluetoothsocket.cpp
+++ b/tests/auto/qbluetoothsocket/tst_qbluetoothsocket.cpp
@@ -142,7 +142,7 @@ void tst_QBluetoothSocket::initTestCase()
     qDebug() << "Starting discovery";
 
     sda->setUuidFilter(QBluetoothUuid(QString(TEST_SERVICE_UUID)));
-    sda->start(QBluetoothServiceDiscoveryAgent::MinimalDiscovery);
+    sda->start(QBluetoothServiceDiscoveryAgent::FullDiscovery);
 
     for (int connectTime = MaxConnectTime; !done_discovery && connectTime > 0; connectTime -= 1000)
         QTest::qWait(1000);
diff --git a/tests/auto/qlowenergycontroller/tst_qlowenergycontroller.cpp b/tests/auto/qlowenergycontroller/tst_qlowenergycontroller.cpp
index ab393210..bc74c693 100644
--- a/tests/auto/qlowenergycontroller/tst_qlowenergycontroller.cpp
+++ b/tests/auto/qlowenergycontroller/tst_qlowenergycontroller.cpp
@@ -148,6 +148,8 @@ void tst_QLowEnergyController::initTestCase()
     }
 #endif
 
+    // QLoggingCategory::setFilterRules(QStringLiteral("qt.bluetooth* = true"));
+
     devAgent = new QBluetoothDeviceDiscoveryAgent(this);
     devAgent->setLowEnergyDiscoveryTimeout(5000);
 
@@ -489,10 +491,12 @@ void tst_QLowEnergyController::tst_concurrentDiscovery()
         } else {
             QCOMPARE(control.state(), QLowEnergyController::ConnectedState);
             QCOMPARE(control2.state(), QLowEnergyController::ConnectedState);
+            QTRY_COMPARE(control2.error(), QLowEnergyController::NoError);
             control2.disconnectFromDevice();
             QTRY_COMPARE(control2.state(), QLowEnergyController::UnconnectedState);
             QTRY_COMPARE(control2.error(), QLowEnergyController::NoError);
             QTRY_COMPARE(control.state(), QLowEnergyController::UnconnectedState);
+            QTRY_COMPARE(control.error(), QLowEnergyController::NoError);
 
             // reconnect control
             control.connectToDevice();
@@ -627,6 +631,8 @@ void tst_QLowEnergyController::tst_concurrentDiscovery()
     }
 
     control.disconnectFromDevice();
+    QTRY_COMPARE(control.state(), QLowEnergyController::UnconnectedState);
+    QCOMPARE(control.error(), QLowEnergyController::NoError);
 }
 
 void tst_QLowEnergyController::verifyServiceProperties(
@@ -1738,7 +1744,7 @@ void tst_QLowEnergyController::tst_writeCharacteristic()
         QSKIP("Cannot connect to remote device");
     }
 
-    QCOMPARE(control.state(), QLowEnergyController::ConnectedState);
+    QTRY_VERIFY_WITH_TIMEOUT(control.state() == QLowEnergyController::ConnectedState, 20000);
     QSignalSpy discoveryFinishedSpy(&control, SIGNAL(discoveryFinished()));
     QSignalSpy stateSpy(&control, SIGNAL(stateChanged(QLowEnergyController::ControllerState)));
     control.discoverServices();
@@ -1866,6 +1872,8 @@ void tst_QLowEnergyController::tst_writeCharacteristic()
 
     control.disconnectFromDevice();
 
+    QTRY_COMPARE(control.state(), QLowEnergyController::UnconnectedState);
+    QCOMPARE(control.error(), QLowEnergyController::NoError);
     // *******************************************
     // write value while disconnected -> error
     errorSpy.clear();
@@ -1945,6 +1953,8 @@ void tst_QLowEnergyController::tst_readWriteDescriptor()
     if (!tempData.isValid()) {
         delete service;
         control.disconnectFromDevice();
+        QTRY_COMPARE(control.state(), QLowEnergyController::UnconnectedState);
+        QCOMPARE(control.error(), QLowEnergyController::NoError);
         QSKIP("Cannot find temperature data characteristic of TI Sensor");
     }
 
@@ -1955,6 +1965,8 @@ void tst_QLowEnergyController::tst_readWriteDescriptor()
     if (!notification.isValid()) {
         delete service;
         control.disconnectFromDevice();
+        QTRY_COMPARE(control.state(), QLowEnergyController::UnconnectedState);
+        QCOMPARE(control.error(), QLowEnergyController::NoError);
         QSKIP("Cannot find temperature data notification of TI Sensor");
     }
 
@@ -2131,6 +2143,8 @@ void tst_QLowEnergyController::tst_readWriteDescriptor()
     QCOMPARE(notification.value(), QByteArray::fromHex("0000"));
 
     control.disconnectFromDevice();
+    QTRY_COMPARE(control.state(), QLowEnergyController::UnconnectedState);
+    QCOMPARE(control.error(), QLowEnergyController::NoError);
 
     // *******************************************
     // write value while disconnected -> error
@@ -2319,6 +2333,8 @@ void tst_QLowEnergyController::tst_customProgrammableDevice()
 
     delete service;
     control.disconnectFromDevice();
+    QTRY_COMPARE(control.state(), QLowEnergyController::UnconnectedState);
+    QCOMPARE(control.error(), QLowEnergyController::NoError);
 }
 
 
@@ -2544,6 +2560,8 @@ void tst_QLowEnergyController::tst_errorCases()
     delete irService;
     delete oadService;
     control.disconnectFromDevice();
+    QTRY_COMPARE(control.state(), QLowEnergyController::UnconnectedState);
+    QCOMPARE(control.error(), QLowEnergyController::NoError);
 }
 
 /*
@@ -2576,7 +2594,7 @@ void tst_QLowEnergyController::tst_writeCharacteristicNoResponse()
         QSKIP("Cannot connect to remote device");
     }
 
-    QCOMPARE(control.state(), QLowEnergyController::ConnectedState);
+    QTRY_VERIFY_WITH_TIMEOUT(control.state() == QLowEnergyController::ConnectedState, 20000);
     QSignalSpy discoveryFinishedSpy(&control, SIGNAL(discoveryFinished()));
     QSignalSpy stateSpy(&control, SIGNAL(stateChanged(QLowEnergyController::ControllerState)));
     control.discoverServices();
@@ -2620,6 +2638,8 @@ void tst_QLowEnergyController::tst_writeCharacteristicNoResponse()
             || !imageIdentityChar.isValid()) {
         delete service;
         control.disconnectFromDevice();
+        QTRY_COMPARE(control.state(), QLowEnergyController::UnconnectedState);
+        QCOMPARE(control.error(), QLowEnergyController::NoError);
         QSKIP("Cannot find OAD char/notification");
     }
 
@@ -2829,6 +2849,8 @@ void tst_QLowEnergyController::tst_writeCharacteristicNoResponse()
 
     delete service;
     control.disconnectFromDevice();
+    QTRY_COMPARE(control.state(), QLowEnergyController::UnconnectedState);
+    QCOMPARE(control.error(), QLowEnergyController::NoError);
 }
 
 QTEST_MAIN(tst_QLowEnergyController)
